Rust文法
========

## Rustとは
- c, c++の代替を目指して開発された
- バイナリにコンパイルされる
- 静的型付け言語
- null安全
- メモリの生存期間はコンパイル時に決まる
- マルチパラダイムプログラミング言語   
    - 手続き型   
    - オブジェクト指向   
    - 関数型
- 命名規則はスネークケース

## 変数
- let   
    - immutable
- let mut   
    - mutable
- shadowing
    - letで上書きできる
    - 型を変換するたびに変数を用意せずに済む

## 定数
- const
- 常に型注釈が必要
- どのスコープでも定義できる

## データ型
- スカラー型   
- 単独の値を表現する   
    - 整数型
      - i32, u32, i64, etc
          - defaultでi32
          - 整数リテラル
              - 1\_000
              - 0xff
              - 0o77
              - 0b1111\_0000   - 浮動小数点型
      - f32, f64
          - defaultでf64
          - 浮動小数点リテラル
              - 2.0
    - 論理値型
      - true, false
      - 型注釈はbool
   - 文字型
      - 型注釈はchar
      - シングルクオーテーション
- 複合型
   - タプル型
      - (1, 2, 3)のように()で囲んだ複数の値, 複数の型でもOK
      - let (x, y) = (1, 2)のようにパターンマッチングでアクセスしたり
      - let x = (3, 4)に対してx.0やx.1でアクセスすることができる
   - 配列型
      - \[1, 2, 3\]のように\[\]で囲んだ複数の値, すべて同じ型
      - 固定長
      - スタック上に確保される

## 例外処理
- Result
   - Ok
   - Err
- .expect()を使うと、Errの場合指定したメッセージを標準出力する
```rust
match Result {
   Ok(i) => ,
   Err(e) => ,
}
```

## 式と文
- ;を末尾につけると文になる
- 何もつけないと式になる
- ->で関数の戻り値の型を定義する

## if式
- if 条件式 {} else{}
- bool型

## ループ
- loop{}
   - break
   - continue
- while 条件式 {}
- for i in 0..10 {}
   - コレクションに対する操作
   - Range型
## スタックとヒープ 
- どちらも実行時に利用されるメモリ
- スタック
   - LIFO
   - 固定長を格納する
- ヒープ
   - コンパイル時にサイズが不定であったり可変なデータを格納する
   - あらかじめある一定のサイズを確保
   - ポインタを使ってアクセス
## 所有権
- 各値は所有者に紐づく
- 所有者は各値に1つ
- 所有者がスコープから外れた場合、値が破棄される
- ムーブ
   - 所有権を渡す
   - コピー元が利用できなくなる点でshallow copyとは異なる
- クローン
   - deep copy
   - .clone()をつかう
## 参照
- 関数に値を引数として渡すと、所有権が関数にムーブされてしまい、関数の呼び出しのあとに、渡した引数を利用できない
- &を変数につけることで変数の値への参照を渡すことができる
- 所有権をもらわずに値を参照することができる
- 関数の引数に参照をとることを借用と呼ぶ
- 同じ参照に対して不変と可変を同じスコープで定義できない

## スライス型
----------
- 値の一部への参照
```rust
[start_index..end_index]
```
- 文字列スライスの型は&str
- 文字列以外にもスライスは作れる
   - 整数型であれば&\[i32\]など

## 構造体
- struct
- rustでは構造体の一部だけをmutにすることはできない
- 同名のフィールドはフィールド初期化省略記法を使う
   - usename
- 構造体更新記法
   - ..user
- タプル構造体
   - タプルに型を与えたい場合
   - Color(i32, i32, i32)
- ユニット様構造体
   - フィールドのない構造体

## メソッド
- impl 構造体{ fn メソッド(&self)}
- selfで構造体にアクセス
- 構造体のフィールドに対する処理
- selfを引数として与えなければ、関連関数も実装できる

## Enum
- enum 名前 {}
- Enum::列挙子
- 同じ列挙型として扱うことができる
- 値をもつことができる
- Option
   - 値が存在するか、存在しないかを表すEnum
   - Rustの型システムに定義されている
   - Option<t>
      - Some(T)
      - None
   - スコープに入れなくても使うことができる
   - Option::を省略してSomeやNoneを使うことができる
   - Option<t>とTは別の型のため、存在しないかもしれないOption<t>に対して、Tと同じ操作をすることができないことを言語仕様で保証している

- フロー制御演算子
```rust
match 式 {
    => ,
}
```
- Option<t>に対してmatchを使うことでSomeの値を利用できる
- _を使うことでdefaultのケースを表現できる

if let
- 一つのパターンにマッチした場合だけなにかをするmatch文の糖衣構文

## モジュール
- mod
   - モジュール定義
   - cargo new hogehoge --lib
   - ;で外部ファイルに処理を分割できる
   - fooモジュールにサブモジュールがなければfoo.rsを作成する
   - fooモジュールにサブモジュールがある場合はfoo/mod.rsを作成する
- pub
   - 要素が公開ならばどの親モジュールを通しても利用可能
   - 要素が非公開ならば直接の親モジュールと子モジュールのみ利用可能
- use
   - 長いフルパス表記を簡略化するために使う
   - javaのimportに似ている
   - モジュールにつかうことができるしEnumにも使うことができる
      - use Enum::{A, B};
   - *を使うことで配下すべてをスコープに入れることができる(glob)
      - use module::hoge::*
   - superを使うことで親モジュールにアクセス
## コレクション
- ベクタ
   - 単一の型を複数持つ可変なコレクション
   - Vec<t>
   - vec![]というマクロがある
   - push
   - pop
   - 所有権と借用が適用される
   - Enumを使うことでVecに複数の型を持たせることができる
- 文字列
   - Rustの言語仕様としての文字列型はスライス&strのみ
   - 標準ライブラリにはString型が存在する
   - UTF8エンコードされた文字列データへの参照
   - String::from
   - to_string
   - push_str()
      - 文字列を引数にとる
   - push()
      - 一文字を引数にとる
   - +
      - add(self, &str)->String
      - s1 + &s2
   - 添字アクセス
   - s\[1\]は文字列の1byte目にアクセスするという意味
   - 一文字＝1byteが保証されていれば問題ないが、マルチバイト文字の場合はパニックが起こる
   - charsやbytesを使って処理をおこ
- ハッシュマップ
   - key, valueで値を保持する
   - key, valueの型はそれぞれ一つ
   - HashMap::new()
   - insert(key, value)
      - 値を上書き
   - entry(key).or_insert(value)
      - 値があればそのまま
      - なければ更新
   - get(key)
      - Option<t>
## エラーハンドリング
- panic!
- Result
   - パターンマッチ
   - マッチガード
      - Error(ref error) if error.kind() == ErrorKind::NotFound =>
   - unwrap
      - OkのときはOkの中身を返す
      - Errのときはpanic!を発生させる
   - expect
      - OkのときはOkの中身を返す
      - Errのときはpanic!を発生させる(メッセージを変更できる)
   - Errを伝搬させる
      - Resultを戻り値の型とする関数
      - File::open()?
      - ?を使うことで省略記法になる
- panic!かResultか
   - 失敗することが想定される場合はResult
   - 契約違反や、回復することができない場合はpanic
   - 型に契約ロジックを集約する

## ジェネリクス
- 異なる型を一つの関数/構造体/メソッドで扱いたいときに利用する
- 関数の場合
   - fn method\_a<t>(item: T) -> T{}
- 構造体の場合
   - struct Point<t>{}
   - struct Point<t, u>{}
- メソッドの場合
   - impl<t> Point<t>{}
   - 特定の型だけメソッド定義をすることができる
      - impl Point<i32>{}
      - i32の構造体は、Tとi32の構造体で定義したメソッドを利用することができる
- Rustのジェネリクスはコンパイル時に具体的な型に変換されるため実行時のパフォーマンスは低下しない

## トレイト
 - 特定の型の振る舞いを他の型に共有することができる
    ```rust
    trait Foo { 
        fn foo(&self) -> String;
    }
   
    impl Foo for FooFoo{
        fn foo(&self) -> String{}
    }
    ```
 - デフォルト実装をTraitに持たせることができる
 - Traitを実装できるのは、localにある型のみ
 - トレイト境界
   - ジェネリクスに対して振る舞いを制限できる
   ```rust
   fn bar<T: foo>(item: T){}
   ```
   - 複数のトレイト境界を設けることもできる
   ```rust
   fn bar<T: foo + display>(item: T){}
   ```
   - where節でトレイト境界を見やすくできる
   ```rust
   fn bar<t, u>(t: T, u: U) -> i32 where T: Display, U: Display
   ```
- ブランケット実装
   - 特定のトレイトを実装する型に対してトレイトを実装することができる
     ```rust
     impl <T: display> ToString for T{
     }
     ```
